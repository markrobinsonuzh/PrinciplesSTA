# Normalization, feature selection, and dimensionality reduction {#sec-seq-normalize-featselect-dimred}


## Normalization

Here we apply normalization methods developed for single-cell RNA-seq data, treating each spot as equivalent to one cell.


## Load previously saved data

We start by loading the previously saved data object(s) (see @sec-seq-quality-control-save-objects).

```{r, message=FALSE, results='hide'}
library(SpatialExperiment)
spe <- readRDS("seq-spe_qc.rds")
```


## Logcounts

Calculate log-transformed normalized counts (abbreviated as "logcounts") using library size factors.

We apply the methods implemented in the `scater` [@McCarthy2017] and `scran` [@Lun2016] packages, which were originally developed for single-cell RNA-seq data, making the assumption here that these methods can be applied to spatial transcriptomics data by treating spots as equivalent to cells.

We use the library size factors methodology since this is the simplest approach, and can easily be applied to spatial transcriptomics data. Alternative approaches that are popular for single-cell RNA-seq data, including normalization by deconvolution, are more difficulty to justify in the context of spot-based spatial transcriptomics data since (i) spots may contain multiple cells from more than one cell type, and (ii) datasets can contain multiple samples (e.g. multiple Visium slides, resulting in sample-specific clustering).

```{r, message=FALSE, fig.height=3.5}
library(scran)

# calculate library size factors
spe <- computeLibraryFactors(spe)

summary(sizeFactors(spe))
hist(sizeFactors(spe), breaks = 20)

# calculate logcounts and store in object
spe <- logNormCounts(spe)

# check
assayNames(spe)
dim(counts(spe))
dim(logcounts(spe))
```


## Save objects for later chapters {#sec-seq-normalization-save-objects}

We also save the object(s) in `.rds` format for re-use within later chapters to speed up the build time of the book.

```{r}
# save object(s)
saveRDS(spe, file = "seq-spe_logcounts.rds")
```



## Feature selection

Here, we apply feature selection methods to identify highly variable genes (HVGs) or spatially variable genes (SVGs), which can then be investigated individually or used as the input for further downstream analyses such as clustering.


## Load previously saved data

Load the previously saved data object(s) (see @sec-seq-normalization-save-objects).

```{r, message=FALSE, results='hide'}
library(SpatialExperiment)
spe <- readRDS("seq-spe_logcounts.rds")
```


## Highly variable genes (HVGs)

We use methods from `scran` [@Lun2016] to identify a set of top highly variable genes (HVGs), which can be used to define major cell types. These methods were originally developed for single-cell RNA-seq data, so here we are making the assumption that spots can be treated as equivalent to cells.

Note that HVGs are defined based only on molecular features (i.e. gene expression), and do not take any spatial information into account. If the biologically meaningful spatial information in this dataset mainly reflects spatial distributions of cell types, then relying on HVGs for downstream analyses may be sufficient. However, many datasets contain further spatial structure that is not captured in this way, which may be investigated using spatially-aware methods such as identifying spatially variable genes (SVGs).

To identify HVGs, we first remove mitochondrial genes, since these are very highly expressed in this dataset and are not of main biological interest.

```{r, message=FALSE}
# identify mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$gene_name)
table(is_mito)

# remove mitochondrial genes
spe <- spe[!is_mito, ]
dim(spe)
```

Then, we apply methods from `scran`. This gives us a list of HVGs, which can be used for further downstream analyses. The parameter `prop` defines how many HVGs we want. For example `prop = 0.1` returns the top 10% of genes.

```{r, message=FALSE, fig.height=5}
library(scran)

# fit mean-variance relationship
dec <- modelGeneVar(spe)

# visualize mean-variance relationship
fit <- metadata(dec)
plot(fit$mean, fit$var, 
     xlab = "mean of log-expression", ylab = "variance of log-expression")
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# select top HVGs
top_hvgs <- getTopHVGs(dec, prop = 0.1)
length(top_hvgs)
```


## Save objects for later chapters {#sec-seq-feature-selection-save-objects}

We also save the object(s) in `.rds` format for re-use within later chapters to speed up the build time of the book.

```{r}
# save object(s)
saveRDS(spe, file = "seq-spe_hvgs.rds")
saveRDS(top_hvgs, file = "seq-top_hvgs.rds")
```


## Spatially variable genes (SVGs)

Alternatively, we can apply methods to identify spatially variable genes (SVGs) instead of HVGs. Here, we define SVGs as any genes with spatially correlated patterns of expression across the tissue area.

Several methods to identify SVGs in ST data have recently been developed, which each have various methodological and computational tradeoffs. These include:

- **nnSVG**: available as an R package from [Bioconductor](https://bioconductor.org/packages/nnSVG) and described by @Weber2023

- **SPARK-X**: available as an R package from [GitHub](https://xzhoulab.github.io/SPARK/) and described by @Zhu2021

- **SPARK**: available as an R package from [GitHub](https://xzhoulab.github.io/SPARK/) and described by @Sun2020

- **SpatialDE**: available as a Python package from [GitHub](https://github.com/Teichlab/SpatialDE) and described by @Svensson2018

Alternatively, standard statistical metrics such as [Moran's I](https://en.wikipedia.org/wiki/Moran%27s_I) statistic or [Geary's C](https://en.wikipedia.org/wiki/Geary%27s_C) statistic may also be used to rank genes by their observed spatial autocorrelation. However, the methods above tend to be more sensitive, since they have been developed for the specific properties of ST data.


### nnSVG

Here, we demonstrate a short example showing how to identify a set of top SVGs using [nnSVG](https://bioconductor.org/packages/nnSVG) [@Weber2023]. This method is available in Bioconductor and can be easily integrated into Bioconductor-based workflows.

In this example, we run nnSVG using a small subset of the dataset for faster runtime. We select a subset by subsampling on the set of spots and including stringent filtering for low-expressed genes. A full analysis using all spots for this dataset and default filtering parameters for Visium data from human brain tissue takes around 45 minutes for one Visium sample on a standard laptop.

```{r, message=FALSE}
library(nnSVG)
```

```{r}
# subsample spots for faster runtime in this example
# note: skip this step in full analysis
n <- 100
set.seed(123)
ix <- sample(seq_len(n), n)
spe_nnSVG <- spe[, ix]

# filter low-expressed and mitochondrial genes
# using stringent filtering for faster runtime in this example
# note: use default filtering in full analysis
spe_nnSVG <- filter_genes(
  spe_nnSVG, filter_genes_ncounts = 10, filter_genes_pcspots = 3
)

# re-calculate logcounts after filtering
spe_nnSVG <- logNormCounts(spe_nnSVG)
```

```{r}
# run nnSVG
set.seed(123)
spe_nnSVG <- nnSVG(spe_nnSVG)
```

```{r}
# investigate results

# show results
head(rowData(spe_nnSVG), 3)

# number of significant SVGs
table(rowData(spe_nnSVG)$padj <= 0.05)

# show results for top n SVGs
rowData(spe_nnSVG)[order(rowData(spe_nnSVG)$rank)[1:6], ]

# identify top-ranked SVG
rowData(spe_nnSVG)$gene_name[which(rowData(spe_nnSVG)$rank == 1)]
```


### Downstream analyses

The set of top SVGs from nnSVG may then be investigated further, e.g. by plotting the spatial expression of several top genes and by comparing the list of top genes with known gene sets associated with biological processes of interest in the dataset. The set of top SVGs may also be used as the input for further downstream analyses such as spatially-aware clustering to define spatial domains (see @sec-seq-clustering).



## Dimensionality reduction

Apply dimensionality reduction methods to visualize the data and to generate inputs for further downstream analyses.


## Load previously saved data

Load the previously saved data object(s) (see @sec-seq-feature-selection-save-objects).

```{r, message=FALSE, results='hide'}
library(SpatialExperiment)
spe <- readRDS("seq-spe_hvgs.rds")
top_hvgs <- readRDS("seq-top_hvgs.rds")
```


## Principal component analysis (PCA)

Apply principal component analysis (PCA) to the set of top highly variable genes (HVGs) to reduce the dimensionality of the dataset, and retain the top 50 principal components (PCs) for further downstream analyses.

This is done for two reasons: (i) to reduce noise due to random variation in expression of biologically uninteresting genes, which are assumed to have expression patterns that are independent of each other, and (ii) to improve computational efficiency during downstream analyses.

We use the computationally efficient implementation of PCA provided in the `scater` package [@McCarthy2017]. This implementation uses randomization, and therefore requires setting a random seed for reproducibility.

```{r, message=FALSE}
library(scater)
```

```{r}
# compute PCA
set.seed(123)
spe <- runPCA(spe, subset_row = top_hvgs)

reducedDimNames(spe)
dim(reducedDim(spe, "PCA"))
```


## Uniform Manifold Approximation and Projection (UMAP)

We also run UMAP on the set of top 50 PCs and retain the top 2 UMAP components, which will be used for visualization purposes.

```{r}
# compute UMAP on top 50 PCs
set.seed(123)
spe <- runUMAP(spe, dimred = "PCA")

reducedDimNames(spe)
dim(reducedDim(spe, "UMAP"))

# update column names for easier plotting
colnames(reducedDim(spe, "UMAP")) <- paste0("UMAP", 1:2)
```


## Save objects for later chapters {#sec-seq-dimensionality-reduction-save-objects}

We also save the object(s) in `.rds` format for re-use within later chapters to speed up the build time of the book.

```{r}
# save object(s)
saveRDS(spe, file = "seq-spe_reduceddims.rds")
```


## Visualizations

Generate plots using plotting functions from the [ggspavis](https://bioconductor.org/packages/ggspavis) package. In the next chapter on clustering, we will add cluster labels to these reduced dimension plots.

```{r, message=FALSE}
library(ggspavis)
```

```{r, fig.width=4.25, fig.height=4.25}
# plot top 2 PCA dimensions
plotDimRed(spe, plot_type = "PCA")

# plot top 2 UMAP dimensions
plotDimRed(spe, plot_type = "UMAP")
```



## References {.unnumbered}
