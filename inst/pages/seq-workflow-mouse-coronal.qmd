# Workflow: Mouse coronal {#sec-seq-workflow-mouse-coronal}

## Introduction

This workflow analyzes a mouse coronal brain section dataset from the 10x Genomics Visium platform. This dataset was generated by 10x Genomics, and the raw data files are publicly available from the [10x Genomics website](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain).



## Description of dataset

This dataset measures transcriptome-wide gene expression on a Visium slide spanning one hemisphere of a mouse coronal brain section. For experimental details, see the [10x Genomics website](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain).

Due to the small size of the mouse brain and the dimensions of the Visium slide (6.5mm x 6.5mm), the measurements span an entire brain hemisphere. Therefore, we can use this dataset to compare gene expression profiles between major anatomical regions of the mouse brain. Due to the small size of cells in the mouse brain, each spot can contain up to 50 cells. In this dataset, we do not know the exact number of cells per spot.



## Load data

The dataset is available in `SpatialExperiment` format from the [STexampleData](https://bioconductor.org/packages/STexampleData) package.

```{r, message=FALSE}
library(SpatialExperiment)
library(STexampleData)

# load object
spe <- Visium_mouseCoronal()
spe
```



## Plot data

As an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide. This confirms that the object has loaded correctly, and the orientation matches the [10x Genomics website](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain).

We use visualization functions from the [ggspavis](https://bioconductor.org/packages/ggspavis) package to generate plots.

```{r, message=FALSE}
library(ggspavis)
```

```{r, fig.height=3.5}
# plot spatial coordinates (spots)
plotSpots(spe)
```



## Quality control (QC)

Subset object to keep only spots over tissue.

```{r}
# subset to keep only spots over tissue
spe <- spe[, colData(spe)$in_tissue == 1]
dim(spe)
```

Calculate spot-level QC metrics using the `scater` package [@McCarthy2017], and store the QC metrics in `colData`.

```{r, message=FALSE}
library(scater)
```

```{r}
# identify mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$gene_name)
table(is_mito)
rowData(spe)$gene_name[is_mito]

# calculate per-spot QC metrics and store in colData
spe <- addPerCellQC(spe, subsets = list(mito = is_mito))
head(colData(spe), 3)
```

Select filtering thresholds for the QC metrics by examining distributions using histograms.

```{r, fig.width=7, fig.height=3}
# histograms of QC metrics
par(mfrow = c(1, 3))
hist(colData(spe)$sum, xlab = "sum", main = "UMIs per spot")
hist(colData(spe)$detected, xlab = "detected", main = "Genes per spot")
hist(colData(spe)$subsets_mito_percent, xlab = "percent mitochondrial", main = "Percent mito UMIs")
par(mfrow = c(1, 1))

# select QC thresholds
qc_lib_size <- colData(spe)$sum < 5000
qc_detected <- colData(spe)$detected < 1000
qc_mito <- colData(spe)$subsets_mito_percent > 30

# number of discarded spots for each QC metric
apply(cbind(qc_lib_size, qc_detected, qc_mito), 2, sum)

# combined set of discarded spots
discard <- qc_lib_size | qc_detected | qc_mito
table(discard)

# store in object
colData(spe)$discard <- discard
```

Plot discarded spots in x-y coordinates on the tissue slide to check if there is any biologically meaningful spatial pattern. This would be problematic, since it would mean we are removing biologically informative spots.

```{r, fig.height=3.5}
# check spatial pattern of discarded spots
plotSpotQC(spe, plot_type = "spot", annotate = "discard")
```

There is one small region with some concentrated discarded spots at the top-left. However, this does not appear to correspond to any specific known anatomical region of interest. We assume that these are low-quality spots, and filtering them out will not cause problems in the biological interpretation.

We filter out the low-quality spots from the object.

```{r}
# filter low-quality spots
spe <- spe[, !colData(spe)$discard]
dim(spe)
```



## Normalization

Next, we calculate log-transformed normalized counts (logcounts) with the library size factors methodology, using methods from `scater` [@McCarthy2017] and `scran` [@Lun2016].

```{r, message=FALSE}
library(scran)
```

```{r, fig.height=3.5}
# calculate library size factors
spe <- computeLibraryFactors(spe)

summary(sizeFactors(spe))
hist(log10(sizeFactors(spe)), xlab = "log10 (size factors)", main = "Size factors")

# calculate logcounts and store in object
spe <- logNormCounts(spe)

assayNames(spe)
```



## Feature selection

Identify a set of top highly variable genes (HVGs), which will be used to define cell types. We use methods from `scran` [@Lun2016], and first filter out mitochondrial genes (since these are very highly expressed and not of biological interest here).

```{r}
# remove mitochondrial genes
spe <- spe[!is_mito, ]
dim(spe)
```

```{r, fig.height=5}
# fit mean-variance relationship
dec <- modelGeneVar(spe)

# visualize mean-variance relationship
fit <- metadata(dec)
plot(fit$mean, fit$var, 
     xlab = "mean of log-expression", ylab = "variance of log-expression")
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# select top HVGs
top_hvgs <- getTopHVGs(dec, prop = 0.1)
length(top_hvgs)
```

Note there are a few extremely highly expressed genes, which influence the fitted mean-variance relationship. We check the names of these genes to decide whether they should be removed as outliers.

```{r}
# identify outlier genes
rev(sort(fit$mean))[1:3]
outlier_ids <- names(rev(sort(fit$mean))[1:3])

rowData(spe)[outlier_ids, ]
```

These appear to be biologically meaningful genes, so we leave them in.



## Spatially-aware feature selection

Alternatively, run [nnSVG](https://bioconductor.org/packages/nnSVG) [@Weber2023] to identify a set of top spatially variable genes (SVGs) instead of HVGs.

Here, we run nnSVG using a small subset of the dataset for faster runtime. We select a subset of the data by subsampling on the set of spots and including stringent filtering for low-expressed genes. For a full analysis, we recommend running `nnSVG` on all spots and using alternative filtering parameters (for Visium data from mouse brain tissue), which takes around 45 minutes for one Visium slide on a standard laptop using multiple cores.

```{r, message=FALSE}
# library(nnSVG)
```

```{r}
# # subsample spots
# n <- 100
# set.seed(123)
# ix <- sample(seq_len(n), n)
# 
# spe_nnSVG <- spe[, ix]
# 
# # filter low-expressed and mitochondrial genes
# # using very stringent filtering parameters for faster runtime in this example
# # note: for a full analysis, use alternative filtering parameters (e.g. defaults)
# spe_nnSVG <- filter_genes(
#   spe_nnSVG, filter_genes_ncounts = 50, filter_genes_pcspots = 5
# )
# 
# # re-calculate logcounts after filtering
# # using library size factors
# spe_nnSVG <- logNormCounts(spe_nnSVG)
# 
# # run nnSVG
# # using a single core for compatibility on build system
# # note: for a full analysis, use multiple cores
# set.seed(123)
# spe_nnSVG <- nnSVG(spe_nnSVG, n_threads = 1)
# 
# # investigate results
# 
# # show results
# head(rowData(spe_nnSVG), 3)
# 
# # number of significant SVGs
# table(rowData(spe_nnSVG)$padj <= 0.05)
# 
# # show results for top n SVGs
# rowData(spe_nnSVG)[order(rowData(spe_nnSVG)$rank)[1:6], ]
# 
# # identify top-ranked SVG
# rowData(spe_nnSVG)$gene_name[which(rowData(spe_nnSVG)$rank == 1)]
```



## Dimensionality reduction

Run principal component analysis (PCA) on the set of top HVGs using `scater` [@McCarthy2017], and retain the top 50 principal components (PCs) for downstream analyses. Also run UMAP on the top 50 PCs, and retain the top 2 UMAP components for visualization purposes.

```{r}
# compute PCA
set.seed(123)
spe <- runPCA(spe, subset_row = top_hvgs)

reducedDimNames(spe)
dim(reducedDim(spe, "PCA"))
```

```{r}
# compute UMAP on top 50 PCs
set.seed(123)
spe <- runUMAP(spe, dimred = "PCA")

reducedDimNames(spe)
dim(reducedDim(spe, "UMAP"))

# update column names for easier plotting
colnames(reducedDim(spe, "UMAP")) <- paste0("UMAP", 1:2)
```



## Clustering

Perform clustering to define cell types. We apply graph-based clustering using the Walktrap method implemented in `scran` [@Lun2016], applied to the top 50 PCs calculated on the set of top HVGs.

```{r}
# graph-based clustering
set.seed(123)
k <- 10
g <- buildSNNGraph(spe, k = k, use.dimred = "PCA")
g_walk <- igraph::cluster_walktrap(g)
clus <- g_walk$membership
table(clus)

# store cluster labels in column 'label' in colData
colLabels(spe) <- factor(clus)
```

Visualize the clusters by plotting in (i) spatial (x-y) coordinates on the tissue slide, and (ii) UMAP dimensions.

```{r, fig.height=3.5}
# define custom color palette
colors <- unname(palette.colors(palette = "Polychrome 36"))

# plot clusters in spatial x-y coordinates
plotSpots(spe, annotate = "label", 
          pal = colors)
```

```{r, fig.width=5, fig.height=4.25}
# plot clusters in UMAP dimensions
plotDimRed(spe, plot_type = "UMAP", 
           annotate = "label", pal = colors)
```



## Differential expression

Identify marker genes by testing for differential gene expression between clusters, using the binomial test implemented in `findMarkers` in `scran` [@Lun2016].

```{r}
# set gene names as row names for easier plotting
rownames(spe) <- rowData(spe)$gene_name

# test for marker genes
markers <- findMarkers(spe, test = "binom", direction = "up")

# returns a list with one DataFrame per cluster
markers
```

```{r, message=FALSE}
library(pheatmap)
```

```{r, fig.width=7, fig.height=7}
# plot log-fold changes for one cluster over all other clusters
# selecting cluster 5
interesting <- markers[[5]]
best_set <- interesting[interesting$Top <= 5, ]
logFCs <- getMarkerEffects(best_set)

pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))
```

```{r, fig.width=7, fig.height=7}
# plot log-transformed normalized expression of top genes for one cluster
top_genes <- head(rownames(interesting))

plotExpression(spe, x = "label", features = top_genes)
```


## References {.unnumbered}
