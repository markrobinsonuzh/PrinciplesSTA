# Mouse coronal workflow

This workflow analyzes a mouse coronal brain section dataset from the 10x Genomics Visium platform. This dataset was generated by 10x Genomics, and the raw data files are publicly available from the [10x Genomics website](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain).


## Description of dataset

This dataset measures transcriptome-wide gene expression on a Visium slide spanning one hemisphere of a mouse coronal brain section. For experimental details, see the [10x Genomics website](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain).

Due to the small size of the mouse brain and the dimensions of the Visium slide (6.5mm x 6.5mm), the measurements span an entire brain hemisphere. Therefore, we can use this dataset to compare gene expression profiles between major anatomical regions of the mouse brain. Due to the small size of cells in the mouse brain, each spot can contain up to 50 cells. In this dataset, we do not know the exact number of cells per spot.


## Load data

The dataset is available in `SpatialExperiment` format from the [STexampleData](https://github.com/lmweber/STexampleData) package.

```{r load_data, message=FALSE}
library(SpatialExperiment)
library(STexampleData)

# load object
spe <- load_data("Visium_mouseCoronal")
spe
```


## Plot data

As an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide. This confirms that the object has loaded correctly, and the orientation matches the [10x Genomics website](https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain).

We use visualization functions from the [ggspavis](https://github.com/lmweber/ggpavis) package to generate plots.

```{r plot_data, message=FALSE, fig.height=3.75}
library(ggspavis)

# plot spatial coordinates (spots)
plotSpots(spe)
```


## Quality control (QC)

Subset object to keep only spots over tissue.

```{r subset_in_tissue}
# subset to keep only spots over tissue
spe <- spe[, spatialData(spe)$in_tissue == 1]
dim(spe)
```


Calculate spot-level QC metrics using the `scater` package [@McCarthy2017], and store the QC metrics in `colData`.

```{r QC_calculate, message=FALSE}
library(scater)

# identify mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$gene_name)
table(is_mito)
rowData(spe)$gene_name[is_mito]

# calculate per-spot QC metrics and store in colData
spe <- addPerCellQC(spe, subsets = list(mito = is_mito))
head(colData(spe), 3)
```


Select filtering thresholds for the QC metrics by examining distributions using histograms.

```{r QC_thresholds, fig.height=3.75}
# histograms of QC metrics
par(mfrow = c(1, 3))
hist(colData(spe)$sum, xlab = "sum", main = "UMIs per spot")
hist(colData(spe)$detected, xlab = "detected", main = "Genes per spot")
hist(colData(spe)$subsets_mito_percent, xlab = "percent mitochondrial", main = "Percent mito UMIs")
par(mfrow = c(1, 1))

# select QC thresholds
qc_lib_size <- colData(spe)$sum < 5000
qc_detected <- colData(spe)$detected < 1000
qc_mito <- colData(spe)$subsets_mito_percent > 30

# number of discarded spots for each QC metric
apply(cbind(qc_lib_size, qc_detected, qc_mito), 2, sum)

# combined set of discarded spots
discard <- qc_lib_size | qc_detected | qc_mito
table(discard)

# store in object
colData(spe)$discard <- discard
```


Plot discarded spots in x-y coordinates on the tissue slide to check if there is any biologically meaningful spatial pattern. This would be problematic, since it would mean we are removing biologically informative spots.

We use QC visualization functions from the [spatzli](https://github.com/lmweber/spatzli) package to generate plots.

```{r QC_check, message=FALSE, fig.height=3.75}
library(spatzli)

# check spatial pattern of discarded spots
plotQCspots(spe, discard = "discard")
```


There is one small region with some concentrated discarded spots at the top-left. However, this does not appear to correspond to any specific known anatomical region of interest. We assume that these are low-quality spots, and filtering them out will not cause problems in the biological interpretation.

We filter out the low-quality spots from the object.

```{r QC_filter}
# filter low-quality spots
spe <- spe[, !colData(spe)$discard]
dim(spe)
```


## Normalization

Next, we calculate log-transformed normalized counts, using pool-based size factors and deconvolution to the spot level, using methods from `scater` [@McCarthy2017] and `scran` [@Lun2016]. Since we have a single sample, there are no blocking factors in the experimental design.

```{r normalization, message=FALSE, fig.height=3.75}
library(scran)

# quick clustering for pool-based size factors
set.seed(123)
qclus <- quickCluster(spe)
table(qclus)

# calculate size factors and store in object
spe <- computeSumFactors(spe, cluster = qclus)

summary(sizeFactors(spe))
hist(log10(sizeFactors(spe)), xlab = "log10 (size factors)", main = "Size factors")

# calculate logcounts (log-transformed normalized counts) and store in object
spe <- logNormCounts(spe)

assayNames(spe)
```


## Feature selection

Identify a set of top highly variable genes (HVGs), which will be used to define cell types. We use methods from `scran` [@Lun2016], and first filter out mitochondrial genes (since these are very highly expressed and not of biological interest here).

```{r feature_selection_mito}
# remove mitochondrial genes
spe <- spe[!is_mito, ]
dim(spe)
```

```{r feature_selection_HVGs, message=FALSE, fig.height=3.75}
# fit mean-variance relationship
dec <- modelGeneVar(spe)

# visualize mean-variance relationship
fit <- metadata(dec)
plot(fit$mean, fit$var, 
     xlab = "mean of log-expression", ylab = "variance of log-expression")
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# select top HVGs
top_hvgs <- getTopHVGs(dec, prop = 0.1)
length(top_hvgs)
```


Note there are a few extremely highly expressed genes, which influence the fitted mean-variance relationship. We check the names of these genes to decide whether they should be removed as outliers.

```{r outliers}
# identify outlier genes
rev(sort(fit$mean))[1:3]
outlier_ids <- names(rev(sort(fit$mean))[1:3])

rowData(spe)[outlier_ids, ]
```

These appear to be biologically meaningful genes, so we leave them in.


## Dimensionality reduction

Run principal component analysis (PCA) using `scater` [@McCarthy2017], and retain the top 50 principal components (PCs) for downstream analyses. Also run UMAP on the top 50 PCs, and retain the top 2 UMAP components for visualization purposes.

```{r dimensionality_reduction_PCA}
# compute PCA
set.seed(123)
spe <- runPCA(spe, subset_row = top_hvgs)

reducedDimNames(spe)
dim(reducedDim(spe, "PCA"))
```

```{r dimensionality_reduction_UMAP}
# compute UMAP on top 50 PCs
set.seed(123)
spe <- runUMAP(spe, dimred = "PCA")

reducedDimNames(spe)
dim(reducedDim(spe, "UMAP"))

# update column names for plotting functions
colnames(reducedDim(spe, "UMAP")) <- paste0("UMAP", 1:2)
```


## Clustering

Perform clustering to define cell types. We apply graph-based clustering using the Walktrap method implemented in `scran` [@Lun2016], applied to the top 50 PCs calculated on the set of top HVGs.

```{r clustering_calculate}
# graph-based clustering
set.seed(123)
k <- 10
g <- buildSNNGraph(spe, k = k, use.dimred = "PCA")
g_walk <- igraph::cluster_walktrap(g)
clus <- g_walk$membership
table(clus)

# store cluster labels in column 'label' in colData
colLabels(spe) <- factor(clus)
```


Visualize the clusters by plotting in (i) spatial x-y coordinates on the tissue slide, and (ii) UMAP dimensions. We use plotting functions from the [ggspavis](https://github.com/lmweber/ggpavis) package.

```{r clustering_plots, message=FALSE, fig.height=3.75}
library(ggspavis)

# define custom color palette
colors <- unname(palette.colors(palette = "Polychrome 36"))

# plot clusters in spatial x-y coordinates
plotSpots(spe, discrete = "label", palette = colors)

# plot clusters in UMAP dimensions
plotDimRed(spe, type = "UMAP", discrete = "label", palette = colors)
```


## Marker genes

Identify marker genes by testing for differential gene expression between clusters, using the binomial test implemented in `findMarkers` in `scran` [@Lun2016].

```{r marker_genes}
# set gene names as row names for visualization purposes
rownames(spe) <- rowData(spe)$gene_name

# test for marker genes
markers <- findMarkers(spe, test = "binom", direction = "up")

# returns a list with one DataFrame per cluster
markers
```

```{r marker_genes_heatmap, message=FALSE, fig.width=7}
library(pheatmap)

# plot log-fold changes for one cluster over all other clusters
# selecting cluster 5
interesting <- markers[[5]]
best_set <- interesting[interesting$Top <= 5, ]
logFCs <- getMarkerEffects(best_set)

pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))
```

```{r marker_genes_expression, fig.width=7}
# plot log-transformed normalized expression of top genes for one cluster
top_genes <- head(rownames(interesting))

plotExpression(spe, x = "label", features = top_genes)
```


